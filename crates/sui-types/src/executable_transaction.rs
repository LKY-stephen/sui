// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0
use crate::auto_executable_transaction::AutoExecutableTransaction;
use crate::base_types::ObjectID;
use crate::messages_checkpoint::CheckpointSequenceNumber;
use crate::object_authenticator::ObjectAuthenticator;
use crate::signature::GenericSignature;
use crate::{committee::EpochId, crypto::AuthorityStrongQuorumSignInfo};

use crate::message_envelope::{Envelope, TrustedEnvelope, VerifiedEnvelope};
use crate::transaction::SenderSignedData;
use crate::transaction::TransactionDataAPI;
use serde::{Deserialize, Serialize};

/// CertificateProof is a proof that a transaction certs existed at a given epoch and hence can be executed.
/// There are two types of proofs: one that is proven by inclusion in a checkpoint and one that is proven by quorum signature.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum CertificateProof {
    /// Validity was proven by inclusion in the given checkpoint
    Checkpoint(EpochId, CheckpointSequenceNumber),
    /// Validity was proven by transaction certificate signature
    Certified(AuthorityStrongQuorumSignInfo),
    /// At least f+1 validators have executed this transaction.
    /// In practice, we will always get 2f+1 (effects cert), but theoretically f+1 is enough to prove
    /// that the transaction is valid.
    QuorumExecuted(EpochId),
    /// Transaction generated by the system, for example Clock update transaction
    SystemTransaction(EpochId),
    /// Validity was proven through voting in consensus.
    Consensus(EpochId),
    /// Validity was proven through Event.
    Object(EpochId, ObjectID),
}

impl CertificateProof {
    pub fn new_from_cert_sig(sig: AuthorityStrongQuorumSignInfo) -> Self {
        Self::Certified(sig)
    }

    pub fn new_from_checkpoint(epoch: EpochId, checkpoint: CheckpointSequenceNumber) -> Self {
        Self::Checkpoint(epoch, checkpoint)
    }

    pub fn new_system(epoch: EpochId) -> Self {
        Self::SystemTransaction(epoch)
    }

    pub fn new_from_consensus(epoch: EpochId) -> Self {
        Self::Consensus(epoch)
    }

    pub fn epoch(&self) -> EpochId {
        match self {
            Self::Checkpoint(epoch, _)
            | Self::QuorumExecuted(epoch)
            | Self::SystemTransaction(epoch)
            | Self::Consensus(epoch)
            | Self::Object(epoch, _) => *epoch,
            Self::Certified(sig) => sig.epoch,
        }
    }
}

/// An ExecutableTransaction is a wrapper of a transaction with a CertificateProof that indicates
/// there existed a valid certificate for this transaction, and hence it can be executed locally.
/// This is an abstraction data structure to cover both the case where the transaction is
/// certified or checkpointed when we schedule it for execution.
pub type ExecutableTransaction = Envelope<SenderSignedData, CertificateProof>;
pub type VerifiedExecutableTransaction = VerifiedEnvelope<SenderSignedData, CertificateProof>;
pub type TrustedExecutableTransaction = TrustedEnvelope<SenderSignedData, CertificateProof>;

impl VerifiedExecutableTransaction {
    pub fn gas_budget(&self) -> u64 {
        self.data().transaction_data().gas_budget()
    }

    // Create verrified executable transaction from an auto executable transaction
    pub fn from_auto_executable_transaction(tx: &AutoExecutableTransaction, id: EpochId) -> Self {
        VerifiedEnvelope::new_from_verified(Envelope::new_from_data_and_sig(
            SenderSignedData::new(
                tx.transaction().clone(),
                vec![GenericSignature::ObjectAuthenticator(
                    ObjectAuthenticator::new(tx.object_id()),
                )],
            ),
            CertificateProof::Object(id, tx.object_id()),
        ))
    }
}
